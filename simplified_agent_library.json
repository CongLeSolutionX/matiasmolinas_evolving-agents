[
  {
    "id": "57aa465a-4098-411c-be87-265d358203c2",
    "name": "AgentCommunicator",
    "record_type": "TOOL",
    "domain": "document_processing",
    "description": "Tool for facilitating communication between agents",
    "code_snippet": "\nfrom typing import Dict, Any, Optional\nimport json\nfrom pydantic import BaseModel, Field\n\nfrom beeai_framework.context import RunContext\nfrom beeai_framework.emitter.emitter import Emitter\nfrom beeai_framework.tools.tool import StringToolOutput, Tool, ToolRunOptions\nfrom beeai_framework.backend.chat import ChatModel\nfrom beeai_framework.backend.message import UserMessage\n\nclass AgentCommunicatorInput(BaseModel):\n    agent_name: str = Field(description=\"Name of the agent to communicate with\")\n    message: str = Field(description=\"The message/request to send\")\n    data: Dict[str, Any] = Field(description=\"Any supporting data to include\", default_factory=dict)\n\nclass AgentCommunicator(Tool[AgentCommunicatorInput, ToolRunOptions, StringToolOutput]):\n    \"\"\"\n    Facilitates communication between agents by formatting requests and routing them to specialized agents.\n    \"\"\"\n    name = \"AgentCommunicator\"\n    description = \"Enables communication between different specialized agents\"\n    input_schema = AgentCommunicatorInput\n\n    def __init__(self, options: Dict[str, Any] | None = None):\n        super().__init__(options=options or {})\n        # Get a chat model from the options or create a default one\n        self.chat_model = options.get(\"chat_model\") if options else None\n        \n    def _create_emitter(self) -> Emitter:\n        return Emitter.root().child(\n            namespace=[\"tool\", \"agent\", \"communicator\"],\n            creator=self,\n        )\n    \n    async def _run(self, input: AgentCommunicatorInput, options: ToolRunOptions | None, context: RunContext) -> StringToolOutput:\n        \"\"\"\n        Process a communication request between agents using an LLM.\n        \n        Args:\n            input: Communication request details including agent name, message, and data\n            \n        Returns:\n            Response from the requested agent\n        \"\"\"\n        try:\n            # Log the communication attempt\n            agent_name = input.agent_name\n            message = input.message\n            data = input.data\n            \n            # If we don't have a chat model, try to get one from the context\n            if not self.chat_model and context and hasattr(context, \"llm\"):\n                self.chat_model = context.llm\n            \n            # If we still don't have a chat model, try to get the default one\n            if not self.chat_model:\n                try:\n                    from beeai_framework.backend.chat import get_default_chat_model\n                    self.chat_model = get_default_chat_model()\n                except:\n                    pass\n                    \n            # Fall back to OpenAI if available\n            if not self.chat_model:\n                try:\n                    from beeai_framework.adapters.litellm.chat import LiteLLMChatModel\n                    self.chat_model = LiteLLMChatModel(\"gpt-4o\", provider_id=\"openai\")\n                except:\n                    return StringToolOutput(json.dumps({\n                        \"error\": \"No chat model available for agent communication\"\n                    }))\n            \n            # Create specialized prompts based on which agent is being contacted\n            if agent_name == \"SpecialistAgent\":\n                # Create a prompt for the specialist agent\n                prompt = f\"\"\"\n                You are a specialist agent that performs detailed document analysis.\n                \n                Analyze the following document and provide a structured response.\n                Return a JSON object with 'analysis' and 'extracted_data' fields.\n                \n                DOCUMENT TYPE: {data.get('document_type', 'unknown')}\n                \n                DOCUMENT CONTENT:\n                {message}\n                \n                ADDITIONAL CONTEXT:\n                {json.dumps(data, indent=2)}\n                \"\"\"\n            else:\n                # Generic communication\n                prompt = f\"\"\"\n                You are simulating agent '{agent_name}'.\n                \n                Please respond to the following message as if you were the agent:\n                {message}\n                \n                ADDITIONAL CONTEXT:\n                {json.dumps(data, indent=2)}\n                \n                Return your response in JSON format with appropriate fields.\n                \"\"\"\n            \n            # Query the LLM\n            message_obj = UserMessage(prompt)\n            response = await self.chat_model.create(messages=[message_obj])\n            response_text = response.get_text_content()\n            \n            # Try to parse the response as JSON\n            try:\n                result = json.loads(response_text)\n            except json.JSONDecodeError:\n                # If the response isn't valid JSON, try to extract JSON from it\n                import re\n                json_match = re.search(r'dummy', response_text, re.DOTALL)\n                if json_match:\n                    try:\n                        result = json.loads(json_match.group(0))\n                    except:\n                        # Structure the response manually\n                        result = {\n                            \"analysis\": {\n                                \"document_type\": data.get(\"document_type\", \"unknown\"),\n                                \"notes\": \"Structured response could not be extracted\"\n                            },\n                            \"extracted_data\": {},\n                            \"raw_response\": response_text[:500]  # Include part of the raw response\n                        }\n                else:\n                    # Structure the response manually\n                    result = {\n                        \"analysis\": {\n                            \"document_type\": data.get(\"document_type\", \"unknown\"),\n                            \"notes\": \"Structured response could not be extracted\"\n                        },\n                        \"extracted_data\": {},\n                        \"raw_response\": response_text[:500]  # Include part of the raw response\n                    }\n            \n            return StringToolOutput(json.dumps(result, indent=2))\n            \n        except Exception as e:\n            error_result = {\n                \"error\": f\"Communication error: {str(e)}\",\n                \"analysis\": {\n                    \"document_type\": data.get(\"document_type\", \"unknown\") if isinstance(data, dict) else \"unknown\",\n                    \"success\": False\n                },\n                \"extracted_data\": {}\n            }\n            return StringToolOutput(json.dumps(error_result, indent=2))\n",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-13T14:33:13.109948",
    "last_updated": "2025-03-13T14:33:13.109961",
    "tags": [
      "communication",
      "agent",
      "tool"
    ],
    "metadata": {}
  },
  {
    "id": "a9ac24fa-bbe6-4e79-b32e-4fa9a2ac8e70",
    "name": "DocumentAnalyzer",
    "record_type": "TOOL",
    "domain": "document_processing",
    "description": "Tool to analyze documents and identify their type",
    "code_snippet": "\nfrom typing import Dict, Any\nimport json\nfrom pydantic import BaseModel, Field\n\nfrom beeai_framework.context import RunContext\nfrom beeai_framework.emitter.emitter import Emitter\nfrom beeai_framework.tools.tool import StringToolOutput, Tool, ToolRunOptions\nfrom beeai_framework.backend.chat import ChatModel\nfrom beeai_framework.backend.message import UserMessage\n\nclass DocumentAnalyzerInput(BaseModel):\n    text: str = Field(description=\"Document text to analyze\")\n\nclass DocumentAnalyzer(Tool[DocumentAnalyzerInput, ToolRunOptions, StringToolOutput]):\n    \"\"\"\n    Analyzes a document to identify its type and key characteristics using an LLM.\n    \"\"\"\n    name = \"DocumentAnalyzer\"\n    description = \"Identifies document type and extracts key information\"\n    input_schema = DocumentAnalyzerInput\n\n    def __init__(self, options: Dict[str, Any] | None = None):\n        super().__init__(options=options or {})\n        # Get a chat model from the options or create a default one\n        self.chat_model = options.get(\"chat_model\") if options else None\n        \n    def _create_emitter(self) -> Emitter:\n        return Emitter.root().child(\n            namespace=[\"tool\", \"document\", \"analyzer\"],\n            creator=self,\n        )\n    \n    async def _run(self, input: DocumentAnalyzerInput, options: ToolRunOptions | None, context: RunContext) -> StringToolOutput:\n        \"\"\"\n        Analyzes a document using an LLM to identify its type and extract key information.\n        \n        Args:\n            input: Document text to analyze\n            \n        Returns:\n            Document analysis including type, confidence, and keywords\n        \"\"\"\n        # If we don't have a chat model, try to get one from the context\n        if not self.chat_model and context and hasattr(context, \"llm\"):\n            self.chat_model = context.llm\n        \n        # If we still don't have a chat model, try to get the default one\n        if not self.chat_model:\n            try:\n                from beeai_framework.backend.chat import get_default_chat_model\n                self.chat_model = get_default_chat_model()\n            except:\n                pass\n                \n        # Fall back to OpenAI if available\n        if not self.chat_model:\n            try:\n                from beeai_framework.adapters.litellm.chat import LiteLLMChatModel\n                self.chat_model = LiteLLMChatModel(\"gpt-4o\", provider_id=\"openai\")\n            except:\n                return StringToolOutput(json.dumps({\n                    \"error\": \"No chat model available for document analysis\"\n                }))\n        \n        # Create the prompt for document analysis\n        prompt = f\"\"\"\n        Please analyze the following document and provide structured information about it.\n        Identify the document type, extract key information, and provide a confidence score.\n        \n        Return the results in JSON format with the following structure:\n        {{\n            \"document_type\": \"Type of document (invoice, medical_record, contract, etc.)\",\n            \"confidence\": 0.0-1.0,\n            \"keywords\": [\"list\", \"of\", \"key\", \"words\"],\n            \"extracted_data\": {{\n                \"field1\": \"value1\",\n                \"field2\": \"value2\",\n                ...\n            }}\n        }}\n        \n        DOCUMENT TO ANALYZE:\n        {input.text}\n        \"\"\"\n        \n        try:\n            # Query the LLM\n            message = UserMessage(prompt)\n            response = await self.chat_model.create(messages=[message])\n            response_text = response.get_text_content()\n            \n            # Try to parse the response as JSON\n            try:\n                result = json.loads(response_text)\n                # Ensure we have all the required fields\n                if not isinstance(result, dict):\n                    result = {\"document_type\": \"unknown\", \"error\": \"Invalid response format\"}\n                if \"document_type\" not in result:\n                    result[\"document_type\"] = \"unknown\"\n                if \"confidence\" not in result:\n                    result[\"confidence\"] = 0.5\n                if \"keywords\" not in result:\n                    result[\"keywords\"] = []\n                if \"extracted_data\" not in result:\n                    result[\"extracted_data\"] = {}\n            except json.JSONDecodeError:\n                # If the response isn't valid JSON, try to extract JSON from it\n                import re\n                json_match = re.search(r'dummy', response_text, re.DOTALL)\n                if json_match:\n                    try:\n                        result = json.loads(json_match.group(0))\n                    except:\n                        result = {\n                            \"document_type\": \"unknown\",\n                            \"confidence\": 0.5,\n                            \"keywords\": [],\n                            \"extracted_data\": {},\n                            \"raw_response\": response_text[:500]  # Include part of the raw response\n                        }\n                else:\n                    # Create a basic response\n                    result = {\n                        \"document_type\": \"unknown\",\n                        \"confidence\": 0.5,\n                        \"keywords\": [],\n                        \"raw_response\": response_text[:500]  # Include part of the raw response\n                    }\n            \n            return StringToolOutput(json.dumps(result, indent=2))\n            \n        except Exception as e:\n            error_result = {\n                \"error\": f\"Error analyzing document: {str(e)}\",\n                \"document_type\": \"unknown\",\n                \"confidence\": 0.0\n            }\n            return StringToolOutput(json.dumps(error_result, indent=2))\n",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-13T14:33:13.113544",
    "last_updated": "2025-03-13T14:33:13.113560",
    "tags": [
      "analysis",
      "tool"
    ],
    "metadata": {}
  },
  {
    "id": "00fbcd75-37f6-4db4-9111-f9231b919c69",
    "name": "SpecialistAgent",
    "record_type": "AGENT",
    "domain": "document_processing",
    "description": "Specialist agent that performs detailed document analysis",
    "code_snippet": "\nfrom typing import List, Dict, Any, Optional\nimport json\nimport re\n\nfrom beeai_framework.agents.react import ReActAgent\nfrom beeai_framework.agents.types import AgentMeta\nfrom beeai_framework.memory import TokenMemory, UnconstrainedMemory\nfrom beeai_framework.backend.chat import ChatModel\nfrom beeai_framework.tools.tool import Tool\n\nclass SpecialistAgentInitializer:\n    \"\"\"\n    Specialist agent that performs detailed document analysis.\n    \n    This agent provides deep expertise for specific document types,\n    extracting important information and providing domain-specific insights.\n    \"\"\"\n    \n    @staticmethod\n    def create_agent(llm: ChatModel, tools: Optional[List[Tool]] = None) -> ReActAgent:\n        \"\"\"Create and configure the specialist agent with tools.\"\"\"\n        # Use empty tools list if none provided\n        if tools is None:\n            tools = []\n            \n        # Define agent metadata\n        meta = AgentMeta(\n            name=\"SpecialistAgent\",\n            description=(\n                \"Specialist agent that performs detailed document analysis. \"\n                \"This agent provides deep expertise for specific document types, \"\n                \"extracting important information and providing domain-specific insights.\"\n            ),\n            tools=tools\n        )\n        \n        # Create the agent\n        agent = ReActAgent(\n            llm=llm,\n            tools=tools,\n            memory=TokenMemory(llm),\n            meta=meta\n        )\n        \n        return agent\n        \n    @staticmethod\n    async def analyze_document(document_text: str, document_type: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Analyzes a document and returns structured information.\n        \n        Args:\n            document_text: The text of the document to analyze\n            document_type: Optional type hint for the document\n            \n        Returns:\n            Structured analysis of the document\n        \"\"\"\n        # Determine document type if not provided\n        if not document_type:\n            lower_text = document_text.lower()\n            if \"invoice\" in lower_text:\n                document_type = \"invoice\"\n            elif \"patient\" in lower_text or \"medical\" in lower_text:\n                document_type = \"medical\"\n            else:\n                document_type = \"unknown\"\n        \n        # Initialize results\n        results = {\n            \"analysis\": {\n                \"document_type\": document_type,\n                \"priority\": \"medium\"\n            },\n            \"extracted_data\": {}\n        }\n        \n        # Extract common data\n        # Dates (YYYY-MM-DD format)\n        date_pattern = r'(\\d{4}-\\d{2}-\\d{2})'\n        dates = re.findall(date_pattern, document_text)\n        if dates:\n            results[\"extracted_data\"][\"dates\"] = dates\n        \n        # Perform document-specific analysis\n        if document_type == \"invoice\":\n            # Analyze invoice\n            SpecialistAgentInitializer._analyze_invoice(document_text, results)\n        elif document_type == \"medical\":\n            # Analyze medical record\n            SpecialistAgentInitializer._analyze_medical_record(document_text, results)\n        else:\n            # Generic analysis for unknown types\n            results[\"analysis\"][\"notes\"] = \"Document type not recognized for specialized analysis\"\n        \n        return results\n    \n    @staticmethod\n    def _analyze_invoice(text: str, results: Dict[str, Any]) -> None:\n        \"\"\"Specialized invoice analysis\"\"\"\n        # Extract vendor\n        vendor_match = re.search(r'Vendor: ([^\\n]+)', text)\n        if vendor_match:\n            results[\"extracted_data\"][\"vendor\"] = vendor_match.group(1).strip()\n        \n        # Extract invoice number\n        invoice_num_match = re.search(r'(?:INVOICE|Invoice)[ #:]+([A-Z0-9]+)', text)\n        if invoice_num_match:\n            results[\"extracted_data\"][\"invoice_number\"] = invoice_num_match.group(1).strip()\n        \n        # Extract total amount\n        total_match = re.search(r'Total[^:]*: ?\\$(\\d+,?\\d*\\.\\d{2})', text)\n        if total_match:\n            total = total_match.group(1).replace(\",\", \"\")\n            results[\"extracted_data\"][\"total_amount\"] = total\n            \n            # Set priority based on amount\n            try:\n                amount = float(total)\n                if amount > 1000:\n                    results[\"analysis\"][\"priority\"] = \"high\"\n                    results[\"analysis\"][\"approval_required\"] = True\n                    results[\"analysis\"][\"notes\"] = \"Large invoice requires manager approval\"\n                else:\n                    results[\"analysis\"][\"approval_required\"] = False\n            except:\n                pass\n        \n        # Extract due date\n        due_date_match = re.search(r'Due Date: (\\d{4}-\\d{2}-\\d{2})', text)\n        if due_date_match:\n            results[\"extracted_data\"][\"due_date\"] = due_date_match.group(1)\n    \n    @staticmethod\n    def _analyze_medical_record(text: str, results: Dict[str, Any]) -> None:\n        \"\"\"Specialized medical record analysis\"\"\"\n        # Extract patient name\n        name_match = re.search(r'Name: ([^\\n]+)', text)\n        if name_match:\n            results[\"extracted_data\"][\"patient_name\"] = name_match.group(1).strip()\n        \n        # Extract patient ID\n        patient_id_match = re.search(r'Patient ID: ([^\\n]+)', text)\n        if patient_id_match:\n            results[\"extracted_data\"][\"patient_id\"] = patient_id_match.group(1).strip()\n        \n        # Extract diagnosis\n        diagnosis_match = re.search(r'Assessment: ([^\\n]+)', text)\n        if diagnosis_match:\n            diagnosis = diagnosis_match.group(1).strip()\n            results[\"extracted_data\"][\"diagnosis\"] = diagnosis\n            \n            # Set priority based on diagnosis severity\n            if \"acute\" in diagnosis.lower() or \"emergency\" in diagnosis.lower():\n                results[\"analysis\"][\"priority\"] = \"high\"\n                results[\"analysis\"][\"follow_up_required\"] = True\n                results[\"analysis\"][\"notes\"] = \"Urgent condition requires immediate follow-up\"\n            else:\n                results[\"analysis\"][\"follow_up_required\"] = False\n        \n        # Extract vital signs\n        vitals = {}\n        temp_match = re.search(r'Temperature: ([^\\n]+)', text)\n        if temp_match:\n            temp = temp_match.group(1).strip()\n            vitals[\"temperature\"] = temp\n            \n            # Flag fever\n            if \"\u00b0F\" in temp and float(temp.replace(\"\u00b0F\", \"\").strip()) > 100:\n                results[\"analysis\"][\"has_fever\"] = True\n        \n        bp_match = re.search(r'Blood Pressure: ([^\\n]+)', text)\n        if bp_match:\n            vitals[\"blood_pressure\"] = bp_match.group(1).strip()\n        \n        if vitals:\n            results[\"extracted_data\"][\"vitals\"] = vitals\n",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-13T14:33:13.117638",
    "last_updated": "2025-03-13T14:33:13.117698",
    "tags": [
      "specialist",
      "agent",
      "analysis"
    ],
    "metadata": {
      "framework": "beeai"
    }
  },
  {
    "id": "297497d6-1e93-42fb-b9de-da786ad7d3e3",
    "name": "CoordinatorAgent",
    "record_type": "AGENT",
    "domain": "document_processing",
    "description": "Primary agent that orchestrates document processing",
    "code_snippet": "\nfrom typing import List, Dict, Any, Optional\nimport json\n\nfrom beeai_framework.agents.react import ReActAgent\nfrom beeai_framework.agents.types import AgentMeta\nfrom beeai_framework.memory import TokenMemory, UnconstrainedMemory\nfrom beeai_framework.backend.chat import ChatModel\nfrom beeai_framework.tools.tool import Tool\n\nclass CoordinatorAgentInitializer:\n    \"\"\"\n    Primary agent that orchestrates document processing.\n    \n    This agent:\n    1. Analyzes the document to identify its type\n    2. Sends the document to a specialist agent for detailed analysis\n    3. Synthesizes the results and provides recommendations\n    \"\"\"\n    \n    @staticmethod\n    def create_agent(llm: ChatModel, tools: Optional[List[Tool]] = None) -> ReActAgent:\n        \"\"\"Create and configure the coordinator agent with tools.\"\"\"\n        # Use empty tools list if none provided\n        if tools is None:\n            tools = []\n            \n        # Define agent metadata\n        meta = AgentMeta(\n            name=\"CoordinatorAgent\",\n            description=(\n                \"Primary agent that orchestrates document processing. \"\n                \"This agent analyzes documents, delegates to specialists, \"\n                \"and synthesizes results with recommendations.\"\n            ),\n            tools=tools\n        )\n        \n        # Create the agent with the necessary tools\n        agent = ReActAgent(\n            llm=llm,\n            tools=tools,\n            memory=TokenMemory(llm),\n            meta=meta\n        )\n        \n        return agent\n        \n    @staticmethod\n    def generate_recommendations(document_type: str, analysis: Dict[str, Any], extracted_data: Dict[str, Any]) -> List[str]:\n        \"\"\"\n        Generate recommendations based on document analysis.\n        \n        Args:\n            document_type: Type of document (invoice, medical, etc.)\n            analysis: Analysis data from specialist agent\n            extracted_data: Data extracted from the document\n            \n        Returns:\n            List of recommendations\n        \"\"\"\n        recommendations = []\n        \n        if document_type == \"invoice\":\n            # Invoice recommendations\n            if \"total_amount\" in extracted_data:\n                try:\n                    amount = float(extracted_data[\"total_amount\"])\n                    if amount > 1000:\n                        recommendations.append(\"HIGH PRIORITY: Review large invoice amount\")\n                    \n                    if \"approval_required\" in analysis and analysis[\"approval_required\"]:\n                        recommendations.append(\"Route to finance manager for approval\")\n                    else:\n                        recommendations.append(\"Process for payment within standard timeframe\")\n                except:\n                    recommendations.append(\"Verify invoice amount\")\n            \n            if \"vendor\" in extracted_data:\n                recommendations.append(f\"Confirm vendor details for {extracted_data['vendor']}\")\n                \n            if \"dates\" in extracted_data and len(extracted_data[\"dates\"]) > 0:\n                recommendations.append(f\"Document date: {extracted_data['dates'][0]}\")\n        \n        elif document_type == \"medical\":\n            # Medical record recommendations\n            if \"diagnosis\" in extracted_data:\n                recommendations.append(f\"Noted diagnosis: {extracted_data['diagnosis']}\")\n                \n            if \"follow_up_required\" in analysis and analysis[\"follow_up_required\"]:\n                recommendations.append(\"PRIORITY: Schedule follow-up appointment\")\n            \n            if \"patient_name\" in extracted_data:\n                recommendations.append(f\"Update patient record for {extracted_data['patient_name']}\")\n        \n        else:\n            # Default recommendations\n            recommendations.append(\"Document requires manual review\")\n            recommendations.append(\"Route to appropriate department based on content\")\n        \n        # Add standard recommendation\n        recommendations.append(\"Archive document according to record retention policy\")\n        \n        return recommendations\n",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-13T14:33:13.131385",
    "last_updated": "2025-03-13T14:33:13.131403",
    "tags": [
      "coordinator",
      "agent",
      "orchestration"
    ],
    "metadata": {
      "framework": "beeai",
      "required_tools": [
        "DocumentAnalyzer",
        "AgentCommunicator"
      ]
    }
  },
  {
    "id": "9c0744dd-a99d-45d3-a7be-dee4499bfd4d",
    "name": "InvoiceProcessorTool",
    "record_type": "TOOL",
    "domain": "Document Processing",
    "description": "Tool to process invoices by extracting key information such as vendor, date, items, and total, handling different formats, and validating data.",
    "code_snippet": "```python\nfrom typing import Dict, Any, List\nfrom pydantic import BaseModel, Field, validator\nimport re\n\nfrom beeai_framework.context import RunContext\nfrom beeai_framework.emitter.emitter import Emitter\nfrom beeai_framework.tools.tool import StringToolOutput, Tool, ToolRunOptions\n\nclass InvoiceProcessorToolInput(BaseModel):\n    invoice_data: str = Field(description=\"Raw text data of the invoice to be processed\")\n\n    @validator('invoice_data')\n    def validate_invoice_data(cls, value):\n        if not value.strip():\n            raise ValueError(\"Invoice data cannot be empty\")\n        return value\n\nclass InvoiceProcessorTool(Tool[InvoiceProcessorToolInput, ToolRunOptions, StringToolOutput]):\n    \"\"\"Processes invoices to extract key information such as vendor, date, items, and total.\"\"\"\n    name = \"InvoiceProcessorTool\"\n    description = \"Extracts key information from invoices, handles different formats, and validates data.\"\n    input_schema = InvoiceProcessorToolInput\n\n    def _create_emitter(self) -> Emitter:\n        return Emitter.root().child(\n            namespace=[\"tool\", \"invoice_processor\"],\n            creator=self,\n        )\n    \n    async def _run(self, input: InvoiceProcessorToolInput, options: ToolRunOptions | None, context: RunContext) -> StringToolOutput:\n        try:\n            invoice_text = input.invoice_data\n            \n            # Extract vendor name\n            vendor_match = re.search(r\"Vendor:\\s*(.+)\", invoice_text)\n            vendor = vendor_match.group(1).strip() if vendor_match else \"Unknown Vendor\"\n            \n            # Extract date\n            date_match = re.search(r\"Date:\\s*(\\d{4}-\\d{2}-\\d{2})\", invoice_text)\n            date = date_match.group(1) if date_match else \"Unknown Date\"\n            \n            # Extract items\n            items_match = re.findall(r\"Item:\\s*(.+?)\\s*Price:\\s*\\$([\\d\\.]+)\", invoice_text)\n            items = [{\"name\": item[0].strip(), \"price\": float(item[1])} for item in items_match]\n            \n            # Extract total\n            total_match = re.search(r\"Total:\\s*\\$([\\d\\.]+)\", invoice_text)\n            total = float(total_match.group(1)) if total_match else 0.0\n            \n            # Validate extracted data\n            if not vendor or not date or not items or total == 0.0:\n                raise ValueError(\"Failed to extract all required information from the invoice.\")\n            \n            # Construct the result\n            result = {\n                \"vendor\": vendor,\n                \"date\": date,\n                \"items\": items,\n                \"total\": total\n            }\n            \n            # Return formatted response\n            import json\n            return StringToolOutput(json.dumps(result, indent=2))\n            \n        except Exception as e:\n            return StringToolOutput(f\"Error processing invoice: {str(e)}\")\n```\n\n### Explanation:\n- **Input Schema**: The `InvoiceProcessorToolInput` class defines a single field `invoice_data` for the raw text of the invoice. It includes a validator to ensure the input is not empty.\n- **Extraction Logic**: The `_run` method uses regular expressions to extract the vendor, date, items, and total from the invoice text. It handles different formats by using flexible regex patterns.\n- **Validation**: The method checks if all required information is extracted and raises an error if any key information is missing.\n- **Error Handling**: The method includes a try-except block to catch and report any errors during processing.\n- **Output**: The extracted data is formatted as a JSON string for easy readability and further processing.",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-13T14:34:15.363416",
    "last_updated": "2025-03-13T14:34:15.363430",
    "tags": [
      "Document Processing",
      "tool"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-13T14:34:15.363348",
        "requirements_summary": "1. Extract key information from invoices like vendor, date, items, and total. 2. Handle different..."
      }
    }
  },
  {
    "id": "35ba7c00-0721-4a1b-a27e-474df466ab45",
    "name": "InvoiceProcessorTool",
    "record_type": "TOOL",
    "domain": "Medical Records",
    "description": "Tool to process invoices by extracting key information such as vendor, date, items, and total, handling different formats, and validating data.",
    "code_snippet": "```python\nfrom typing import Dict, Any, List\nfrom pydantic import BaseModel, Field, validator\nimport re\n\nfrom beeai_framework.context import RunContext\nfrom beeai_framework.emitter.emitter import Emitter\nfrom beeai_framework.tools.tool import StringToolOutput, Tool, ToolRunOptions\n\nclass MedicalRecordProcessorToolInput(BaseModel):\n    medical_record_data: str = Field(description=\"Raw text data of the medical record to be processed\")\n\n    @validator('medical_record_data')\n    def validate_medical_record_data(cls, value):\n        if not value.strip():\n            raise ValueError(\"Medical record data cannot be empty\")\n        return value\n\nclass MedicalRecordProcessorTool(Tool[MedicalRecordProcessorToolInput, ToolRunOptions, StringToolOutput]):\n    \"\"\"Processes medical records to extract key information such as patient details, diagnosis, and treatment plans.\"\"\"\n    name = \"MedicalRecordProcessorTool\"\n    description = \"Extracts key information from medical records, identifies medical terms, and formats data in a structured way.\"\n    input_schema = MedicalRecordProcessorToolInput\n\n    def _create_emitter(self) -> Emitter:\n        return Emitter.root().child(\n            namespace=[\"tool\", \"medical_record_processor\"],\n            creator=self,\n        )\n    \n    async def _run(self, input: MedicalRecordProcessorToolInput, options: ToolRunOptions | None, context: RunContext) -> StringToolOutput:\n        try:\n            medical_text = input.medical_record_data\n            \n            # Extract patient name\n            patient_match = re.search(r\"Patient Name:\\s*(.+)\", medical_text)\n            patient_name = patient_match.group(1).strip() if patient_match else \"Unknown Patient\"\n            \n            # Extract date of birth\n            dob_match = re.search(r\"Date of Birth:\\s*(\\d{4}-\\d{2}-\\d{2})\", medical_text)\n            dob = dob_match.group(1) if dob_match else \"Unknown DOB\"\n            \n            # Extract diagnosis\n            diagnosis_match = re.search(r\"Diagnosis:\\s*(.+)\", medical_text)\n            diagnosis = diagnosis_match.group(1).strip() if diagnosis_match else \"Unknown Diagnosis\"\n            \n            # Extract treatment plan\n            treatment_match = re.search(r\"Treatment Plan:\\s*(.+)\", medical_text)\n            treatment_plan = treatment_match.group(1).strip() if treatment_match else \"Unknown Treatment Plan\"\n            \n            # Validate extracted data\n            if not patient_name or not dob or not diagnosis or not treatment_plan:\n                raise ValueError(\"Failed to extract all required information from the medical record.\")\n            \n            # Construct the result\n            result = {\n                \"patient_name\": patient_name,\n                \"date_of_birth\": dob,\n                \"diagnosis\": diagnosis,\n                \"treatment_plan\": treatment_plan\n            }\n            \n            # Return formatted response\n            import json\n            return StringToolOutput(json.dumps(result, indent=2))\n            \n        except Exception as e:\n            return StringToolOutput(f\"Error processing medical record: {str(e)}\")\n\n```\n\n### Explanation:\n- **Input Schema**: The `MedicalRecordProcessorToolInput` class defines a single field `medical_record_data` for the raw text of the medical record. It includes a validator to ensure the input is not empty.\n- **Extraction Logic**: The `_run` method uses regular expressions to extract the patient name, date of birth, diagnosis, and treatment plan from the medical record text. It uses flexible regex patterns to handle different formats.\n- **Validation**: The method checks if all required information is extracted and raises an error if any key information is missing.\n- **Error Handling**: The method includes a try-except block to catch and report any errors during processing.\n- **Output**: The extracted data is formatted as a JSON string for easy readability and further processing.\n\nThis adaptation maintains the core logic of the original tool while adjusting it to handle medical records, ensuring compliance with the specified guidelines and constraints.",
    "version": "1.0.1",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-13T14:34:55.254394",
    "last_updated": "2025-03-13T14:34:55.254438",
    "parent_id": "9c0744dd-a99d-45d3-a7be-dee4499bfd4d",
    "tags": [
      "Document Processing",
      "tool"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-13T14:34:15.363348",
        "requirements_summary": "1. Extract key information from invoices like vendor, date, items, and total. 2. Handle different..."
      },
      "evolved_at": "2025-03-13T14:34:55.254461",
      "evolved_from": "9c0744dd-a99d-45d3-a7be-dee4499bfd4d",
      "previous_version": "1.0.0",
      "domain_adaptation": {
        "original_domain": "Document Processing",
        "target_domain": "Medical Records",
        "adaptation_timestamp": "2025-03-13T14:34:55.259174"
      },
      "evolution_strategy": {
        "strategy": "domain_adaptation",
        "description": "Specialized for adapting components to new domains",
        "preservation_level": 0.6,
        "timestamp": "2025-03-13T14:34:55.269928"
      }
    }
  },
  {
    "id": "59cfe5f5-5922-4845-920f-0f2f63387ffa",
    "name": "InvoiceProcessorTool",
    "record_type": "TOOL",
    "domain": "Document and Medical Records",
    "description": "Tool to process both invoices and medical records by extracting key information and formatting data in a structured way.",
    "code_snippet": "```python\nfrom typing import Dict, Any, List, Union\nfrom pydantic import BaseModel, Field, validator\nimport re\nimport json\n\nfrom beeai_framework.context import RunContext\nfrom beeai_framework.emitter.emitter import Emitter\nfrom beeai_framework.tools.tool import StringToolOutput, Tool, ToolRunOptions\n\nclass DocumentProcessorToolInput(BaseModel):\n    document_data: str = Field(description=\"Raw text data of the document to be processed\")\n\n    @validator('document_data')\n    def validate_document_data(cls, value):\n        if not value.strip():\n            raise ValueError(\"Document data cannot be empty\")\n        return value\n\nclass DocumentProcessorTool(Tool[DocumentProcessorToolInput, ToolRunOptions, StringToolOutput]):\n    \"\"\"Processes documents to extract key information such as vendor, date, items, total, patient information, diagnosis, and treatment plans.\"\"\"\n    name = \"DocumentProcessorTool\"\n    description = \"Extracts key information from invoices and medical records, handles different formats, and validates data.\"\n    input_schema = DocumentProcessorToolInput\n\n    def _create_emitter(self) -> Emitter:\n        return Emitter.root().child(\n            namespace=[\"tool\", \"document_processor\"],\n            creator=self,\n        )\n    \n    async def _run(self, input: DocumentProcessorToolInput, options: ToolRunOptions | None, context: RunContext) -> StringToolOutput:\n        try:\n            document_text = input.document_data\n            \n            # Extract vendor name (for invoices)\n            vendor_match = re.search(r\"Vendor:\\s*(.+)\", document_text)\n            vendor = vendor_match.group(1).strip() if vendor_match else \"Unknown Vendor\"\n            \n            # Extract date\n            date_match = re.search(r\"Date:\\s*(\\d{4}-\\d{2}-\\d{2})\", document_text)\n            date = date_match.group(1) if date_match else \"Unknown Date\"\n            \n            # Extract items (for invoices)\n            items_match = re.findall(r\"Item:\\s*(.+?)\\s*Price:\\s*\\$([\\d\\.]+)\", document_text)\n            items = [{\"name\": item[0].strip(), \"price\": float(item[1])} for item in items_match]\n            \n            # Extract total (for invoices)\n            total_match = re.search(r\"Total:\\s*\\$([\\d\\.]+)\", document_text)\n            total = float(total_match.group(1)) if total_match else 0.0\n            \n            # Extract patient information (for medical records)\n            patient_match = re.search(r\"Patient:\\s*(.+)\", document_text)\n            patient = patient_match.group(1).strip() if patient_match else \"Unknown Patient\"\n            \n            # Extract diagnosis (for medical records)\n            diagnosis_match = re.search(r\"Diagnosis:\\s*(.+)\", document_text)\n            diagnosis = diagnosis_match.group(1).strip() if diagnosis_match else \"Unknown Diagnosis\"\n            \n            # Extract treatment plans (for medical records)\n            treatment_match = re.search(r\"Treatment Plan:\\s*(.+)\", document_text)\n            treatment_plan = treatment_match.group(1).strip() if treatment_match else \"Unknown Treatment Plan\"\n            \n            # Construct the result\n            result = {\n                \"vendor\": vendor,\n                \"date\": date,\n                \"items\": items,\n                \"total\": total,\n                \"patient\": patient,\n                \"diagnosis\": diagnosis,\n                \"treatment_plan\": treatment_plan\n            }\n            \n            # Validate extracted data\n            if not any([vendor, patient]) or not date:\n                raise ValueError(\"Failed to extract all required information from the document.\")\n            \n            # Return formatted response\n            return StringToolOutput(json.dumps(result, indent=2))\n            \n        except Exception as e:\n            return StringToolOutput(f\"Error processing document: {str(e)}\")\n\n```\n\n### Explanation of Changes:\n- **Input Schema**: The `DocumentProcessorToolInput` class now uses `document_data` to generalize the input for both invoices and medical records.\n- **Extraction Logic**: The `_run` method has been expanded to extract patient information, diagnosis, and treatment plans in addition to the existing invoice data.\n- **Validation**: The method checks if at least one of the key identifiers (vendor or patient) and the date are extracted, raising an error if not.\n- **Output**: The extracted data is formatted as a JSON string, maintaining compatibility with the original interface.\n- **Documentation**: The code includes comments explaining the purpose of each section, ensuring clarity and maintainability.",
    "version": "1.0.1",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-13T14:35:44.300940",
    "last_updated": "2025-03-13T14:35:44.301003",
    "parent_id": "9c0744dd-a99d-45d3-a7be-dee4499bfd4d",
    "tags": [
      "Document Processing",
      "tool"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-13T14:34:15.363348",
        "requirements_summary": "1. Extract key information from invoices like vendor, date, items, and total. 2. Handle different..."
      },
      "evolved_at": "2025-03-13T14:35:44.301146",
      "evolved_from": "9c0744dd-a99d-45d3-a7be-dee4499bfd4d",
      "previous_version": "1.0.0",
      "domain_adaptation": {
        "original_domain": "Document Processing",
        "target_domain": "Document and Medical Records",
        "adaptation_timestamp": "2025-03-13T14:35:44.309972"
      },
      "evolution_strategy": {
        "strategy": "domain_adaptation",
        "description": "Specialized for adapting components to new domains",
        "preservation_level": 0.6,
        "timestamp": "2025-03-13T14:35:44.314741"
      }
    }
  }
]